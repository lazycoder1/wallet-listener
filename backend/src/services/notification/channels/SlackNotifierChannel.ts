import { Prisma } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import prisma from '../../../prisma';
import logger from '../../../config/logger';
import type { NotificationChannel, NotificationMessage } from '../notificationService'; // Assuming this path

// Define a more specific type for the data we expect in a deposit notification for Slack
interface SlackDepositMessageData {
    recipientAddress: string;
    rawValue: string; // Raw transfer amount (string representation of BigInt or number)
    formattedValue: string; // Human-readable transfer amount, e.g., "10.5"
    tokenSymbol: string;
    tokenDecimals: number;
    tokenContractAddress?: string; // 'NATIVE' or actual contract address
    usdValue: number;
    transactionHash: string;
    senderAddress?: string;
    chainName: string; // e.g., "Ethereum", "Polygon", "Tron"
    blockNumber?: bigint | number;
    // The pre-formatted summary message including balances, generated by NotificationService.notifyDeposit
    // This can be used as a fallback or part of the Slack message.
    summaryMessage?: string;
}

function getExplorerLink(chainName: string, txHash: string): string {
    const lowerChainName = chainName.toLowerCase();
    if (lowerChainName.includes('ethereum')) {
        return `https://etherscan.io/tx/${txHash}`;
    }
    if (lowerChainName.includes('polygon')) {
        return `https://polygonscan.com/tx/${txHash}`;
    }
    if (lowerChainName.includes('bsc') || lowerChainName.includes('bnb')) {
        return `https://bscscan.com/tx/${txHash}`;
    }
    if (lowerChainName.includes('tron')) {
        return `https://tronscan.org/#/transaction/${txHash}`;
    }
    return ''; // Fallback or throw error
}

export class SlackNotifierChannel implements NotificationChannel {
    async send(notification: NotificationMessage): Promise<void> {
        // We are primarily interested in deposit-like notifications for now
        // A more robust way would be to have a type in NotificationMessage
        if (notification.title !== 'New Deposit Detected' && notification.title !== 'New Transfer Detected') {
            // logger.debug({ msg: 'SlackNotifierChannel: Skipping notification not titled New Deposit/Transfer Detected', title: notification.title });
            return; // Only process deposit/transfer notifications
        }

        const data = notification.data as SlackDepositMessageData;
        if (!data || !data.recipientAddress || !data.transactionHash) {
            logger.warn({ msg: 'SlackNotifierChannel: Received notification with insufficient data for Slack message', notificationData: data });
            return;
        }

        try {
            const companyAddress = await prisma.companyAddress.findFirst({
                where: {
                    address: { address: data.recipientAddress.toLowerCase() },
                    isActive: true,
                },
                include: {
                    company: {
                        include: {
                            slackConfiguration: true,
                        },
                    },
                    address: true, // To get addressId
                },
            });

            if (!companyAddress || !companyAddress.company || !companyAddress.company.slackConfiguration) {
                logger.debug({ msg: 'SlackNotifierChannel: No company or Slack configuration found for address', recipientAddress: data.recipientAddress });
                return;
            }

            const { company } = companyAddress;
            const slackConfig = company.slackConfiguration;

            if (!slackConfig.isEnabled || !slackConfig.channelId || !slackConfig.accessToken) {
                logger.debug({
                    msg: 'SlackNotifierChannel: Slack notifications are disabled, channelId, or accessToken is missing for company',
                    companyId: company.id,
                    hasChannelId: !!slackConfig.channelId,
                    hasAccessToken: !!slackConfig.accessToken
                });
                return;
            }

            // Check threshold (ensure alertThreshold is treated as a number/Decimal)
            const alertThreshold = new Decimal(slackConfig.alertThreshold || 0);
            const transferValueUSD = new Decimal(data.usdValue);

            if (transferValueUSD.lt(alertThreshold)) {
                logger.info({
                    msg: 'SlackNotifierChannel: Transfer value is below threshold, not sending notification',
                    companyId: company.id,
                    transferValueUSD: transferValueUSD.toString(),
                    alertThreshold: alertThreshold.toString(),
                });
                return;
            }

            const explorerLink = getExplorerLink(data.chainName, data.transactionHash);

            // Construct Slack message using Block Kit
            // Use data.summaryMessage if available and suitable, or construct a new one.
            const mainMessageText = data.summaryMessage ||
                `Wallet ${data.recipientAddress} received a deposit of ${data.formattedValue} ${data.tokenSymbol} (approx. $${data.usdValue.toFixed(2)}) on ${data.chainName}.`;

            const blocks = [
                {
                    type: 'header',
                    text: {
                        type: 'plain_text',
                        text: 'ðŸ’° New Transaction Alert!',
                        emoji: true,
                    },
                },
                {
                    type: 'section',
                    text: {
                        type: 'mrkdwn',
                        text: `*Company:* ${company.name}\n*Chain:* ${data.chainName}`,
                    },
                },
                {
                    type: 'section',
                    fields: [
                        {
                            type: 'mrkdwn',
                            text: `*To Address:*\n\`${data.recipientAddress}\``,
                        },
                        {
                            type: 'mrkdwn',
                            text: `*From Address:*\n\`${data.senderAddress || 'N/A'}\``,
                        },
                        {
                            type: 'mrkdwn',
                            text: `*Amount:*\n${data.formattedValue} ${data.tokenSymbol}`,
                        },
                        {
                            type: 'mrkdwn',
                            text: `*Value (USD):*\n~$${data.usdValue.toFixed(2)}`,
                        },
                    ],
                },
                {
                    type: 'context',
                    elements: [
                        {
                            type: 'mrkdwn',
                            text: explorerLink ? `<${explorerLink}|View Transaction>` : `Tx: \`${data.transactionHash}\``,
                        },
                        data.blockNumber ? {
                            type: 'mrkdwn',
                            text: ` | Block: ${data.blockNumber.toString()}`,
                        } : null,
                    ].filter(Boolean), // Remove nulls if blockNumber is not present
                },
                {
                    type: 'divider',
                },
                {
                    type: 'context',
                    elements: [
                        {
                            type: 'plain_text',
                            text: data.summaryMessage || 'Balance details included in main message or not available.',
                            emoji: true
                        }
                    ]
                }
            ];

            const slackApiUrl = 'https://slack.com/api/chat.postMessage';
            const response = await fetch(slackApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json; charset=utf-8',
                    Authorization: `Bearer ${slackConfig.accessToken}`,
                },
                body: JSON.stringify({
                    channel: slackConfig.channelId,
                    blocks: blocks,
                    text: mainMessageText, // Fallback for notifications
                }),
            });

            const responseData = await response.json() as { ok: boolean; error?: string;[key: string]: any };

            if (!responseData.ok) {
                logger.error({
                    msg: 'Slack API error sending notification',
                    companyId: company.id,
                    slackChannelId: slackConfig.channelId,
                    error: responseData.error,
                    slackResponse: responseData
                });
                // Optionally, update slackConfig.lastError in DB
                await prisma.slackConfiguration.update({
                    where: { id: slackConfig.id },
                    data: { lastError: `API Error: ${responseData.error}` }
                }).catch((dbErr: any) => logger.error("Failed to update lastError on SlackConfiguration", { companyId: company.id, dbError: dbErr }));

            } else {
                logger.info({
                    msg: 'Successfully sent Slack notification',
                    companyId: company.id,
                    slackChannelId: slackConfig.channelId,
                    messageId: responseData.ts // Slack message timestamp, can be used as an ID
                });
                // Clear lastError if it was previously set
                if (slackConfig.lastError) {
                    await prisma.slackConfiguration.update({
                        where: { id: slackConfig.id },
                        data: { lastError: null }
                    }).catch((dbErr: any) => logger.error("Failed to clear lastError on SlackConfiguration", { companyId: company.id, dbError: dbErr }));
                }

                // Log alert to database
                try {
                    // Ensure rawValue is a string for Decimal conversion
                    const rawAmountForDb = new Decimal(data.rawValue.toString());

                    await prisma.alert.create({
                        data: {
                            companyId: company.id,
                            addressId: companyAddress.addressId,
                            transactionHash: data.transactionHash,
                            // Amount should be the token amount, not USD. 
                            // This requires rawValue and decimals to be correctly passed.
                            amount: rawAmountForDb,
                            tokenSymbol: data.tokenSymbol,
                            slackMessageId: responseData.ts,
                            alertSentAt: new Date(), // Already default, but good to be explicit
                        },
                    });
                } catch (dbError) {
                    logger.error({
                        msg: 'Failed to log alert to database after sending Slack message',
                        companyId: company.id,
                        error: dbError,
                    });
                }
            }
        } catch (error: any) {
            logger.error({
                msg: 'Error in SlackNotifierChannel send method',
                recipientAddress: data.recipientAddress,
                errorMessage: error.message,
                errorStack: error.stack,
                errorDetails: error
            });
        }
    }
} 